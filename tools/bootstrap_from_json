#!/usr/bin/env php
<?php
/* libdogma
 * Copyright (C) 2012 Romain "Artefact2" Dalmaso <artefact2@gmail.com>
 *
 * This program is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see
 * <http://www.gnu.org/licenses/>.
 */

ini_set('memory_limit', '-1');

function fatal($message) {
	global $argv;

	fwrite(STDERR, $argv[0].": FATAL ".$message."\n");
	die(1);
}

function warn($message) {
	global $argv;

	fwrite(STDERR, $argv[0].": WARNING ".$message."\n");
}

function escape_c_string($str) {
	return '"'.str_replace('"', '\"', $str).'"';
}

$neededjson = array(
	'groups' => 'invgroups.json',
	'types' => 'invtypes.json',
	'attribs' => 'dgmattribs.json',
	'typeattribs' => 'dgmtypeattribs.json',
	'effects' => 'dgmeffects.json',
	'typeeffects' => 'dgmtypeeffects.json',
	'expressions' => 'dgmexpressions.json',
);
$json = array();

if($argc !== 2) {
	echo "Usage: ".$argv[0]." <path_to_json_dump>\n";
	die(2);
}

$jsonpath = rtrim($argv[1], '/');
foreach($neededjson as $idx => $file) {
	$file = $jsonpath.'/'.$file;
	if(!file_exists($file)) fatal('could not find '.$file);

	$jsontext = file_get_contents($file);
	if($jsontext === false) fatal('could not read '.$file);

	$json[$idx] = json_decode($jsontext, true);
	if(json_last_error() !== JSON_ERROR_NONE) fatal('could not parse JSON in '.$file);
}

$targetsource = __DIR__.'/../src/tables-data.c';
if(file_exists($targetsource)) fatal('cowardly refusing to overwrite '.$targetsource);

$c = fopen($targetsource, 'xb');
if($c === false) fatal('could not open '.$targetsource.' for writing');

fwrite(
	$c,
	"/* libdogma */\n\n"
	."/* THIS FILE HAS BEEN AUTOGENERATED. DO NOT MODIFY IT MANUALLY.\n"
	." *\n"
	." * ".__FILE__."\n"
	." * ".date('r')." */\n"
	."\n\n");

/* -------- Types -------- */

$groupsbyid = array();
$usedtypesbyid = array();

foreach($json['groups'] as $g) {
	$groupsbyid[$g['groupID']] = $g;
}
ksort($groupsbyid);

foreach($json['types'] as $t) {
	if($t['published'] !== true || $groupsbyid[$t['groupID']]['published'] !== true
	   || !in_array($groupsbyid[$t['groupID']]['categoryID'], array(6, 7, 8, 16, 18, 20, 32), true)) {
		continue;
	}

	$usedtypesbyid[$t['typeID']] = $t;
}
ksort($usedtypesbyid);

fwrite($c, "static const dogma_type_t dogma_table_types[] = {\n");
foreach($usedtypesbyid as $t) {
	fwrite($c, "\t{ "
	       .$t['typeID'].'U'
	       .", ".$t['volume']
	       .", ".$t['mass']
	       .", ".$t['capacity']
	       .", ".$t['groupID'].'U'
	       .", ".$groupsbyid[$t['groupID']]['categoryID'].'U'
	       ." },\n");
}
fwrite($c, "\t{ 0U, 0, 0, 0, 0U, 0U }\n");
fwrite($c, "};\n");

/* -------- Attributes -------- */

$usedattributesbyid = array();
$usedtypeattributes = array();

foreach($json['typeattribs'] as $ta) {
	if(!isset($usedtypesbyid[$ta['typeID']])) {
		continue;
	}

	$usedattributesbyid[$ta['attributeID']] = true;
	$usedtypeattributes[] = $ta;
}

foreach($json['attribs'] as $a) {
	if(!isset($usedattributesbyid[$a['attributeID']])) {
		continue;
	}

	$usedattributesbyid[$a['attributeID']] = $a;
}
ksort($usedattributesbyid);

fwrite($c, "static const dogma_attribute_t dogma_table_attributes[] = {\n");
foreach($usedattributesbyid as $a) {
	fwrite($c, "\t{ "
	       .$a['attributeID'].'U'
	       .", ".$a['defaultValue']
	       .", ".($a['stackable'] ? 'true' : 'false')
	       .", ".($a['highIsGood'] ? 'true' : 'false')
	       ." },\n");
}
fwrite($c, "\t{ 0U, 0, false, false }\n");
fwrite($c, "};\n");

/* -------- Effects -------- */

$usedeffectsbyid = array();
$usedtypeeffects = array();
$expressionstoadd = array();

foreach($json['typeeffects'] as $te) {
	if(!isset($usedtypesbyid[$te['typeID']])) {
		continue;
	}

	$usedeffectsbyid[$te['effectID']] = true;
	$usedtypeeffects[] = $te;
}

foreach($json['effects'] as $e) {
	if(!isset($usedeffectsbyid[$e['effectID']])) {
		continue;
	}

	$usedeffectsbyid[$e['effectID']] = $e;
	$expressionstoadd[] = $e['preExpression'];
	$expressionstoadd[] = $e['postExpression'];
}
ksort($usedeffectsbyid);

fwrite($c, "static const dogma_effect_t dogma_table_effects[] = {\n");
foreach($usedeffectsbyid as $e) {
	fwrite($c, "\t{ "
	       .$e['effectID'].'U'
	       .", ".$e['effectCategory'].'U'
	       .", ".$e['preExpression'].'U'
	       .", ".$e['postExpression'].'U'
	       .", ".(int)$e['durationAttributeID'].'U'
	       .", ".(int)$e['trackingSpeedAttributeID'].'U'
	       .", ".(int)$e['dischargeAttributeID'].'U'
	       .", ".(int)$e['rangeAttributeID'].'U'
	       .", ".(int)$e['falloffAttributeID'].'U'
	       ." },\n");
}
fwrite($c, "\t{ 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U }\n");
fwrite($c, "};\n");

/* -------- Type attributes / Type effects -------- */

usort($usedtypeattributes, function($a, $b) {
		$delta1 = $a['typeID'] - $b['typeID'];
		$delta2 = $a['attributeID'] - $b['attributeID'];

		return ($delta1 !== 0) ? $delta1 : $delta2;
	});
usort($usedtypeeffects, function($a, $b) {
		$delta1 = $a['typeID'] - $b['typeID'];
		$delta2 = $a['effectID'] - $b['effectID'];

		return ($delta1 !== 0) ? $delta1 : $delta2;
	});

fwrite($c, "static const dogma_type_attribute_t dogma_table_type_attributes[] = {\n");
foreach($usedtypeattributes as $ta) {
	fwrite($c, "\t{ "
	       .$ta['typeID'].'U'
	       .", ".$ta['attributeID'].'U'
	       .", ".$ta['value']
	       ." },\n");
}
fwrite($c, "\t{ 0U, 0U, 0 }\n");
fwrite($c, "};\n");

fwrite($c, "static const dogma_type_effect_t dogma_table_type_effects[] = {\n");
foreach($usedtypeeffects as $te) {
	fwrite($c, "\t{ "
	       .$te['typeID'].'U'
	       .", ".$te['effectID'].'U'
	       ." },\n");
}
fwrite($c, "\t{ 0U, 0U }\n");
fwrite($c, "};\n");

/* -------- Expressions -------- */

$expressionsbyid = array();
$usedexpressionsbyid = array();

foreach($json['expressions'] as $e) {
	$expressionsbyid[$e['expressionID']] = $e;
}

while($expressionstoadd !== array()) {
	$addfurther = array();

	foreach($expressionstoadd as $id) {
		if($id === null) continue;
		if(isset($usedexpressionsbyid[$id])) continue;

		$usedexpressionsbyid[$id] = $expressionsbyid[$id];
		$addfurther[] = $expressionsbyid[$id]['arg1'];
		$addfurther[] = $expressionsbyid[$id]['arg2'];
	}

	$expressionstoadd = $addfurther;
}
ksort($usedexpressionsbyid);
unset($expressionsbyid);

fwrite($c, "static const dogma_expression_t dogma_table_expressions[] = {\n");
foreach($usedexpressionsbyid as $e) {
	if($e['operandID'] === 21) { /* DEFASSOCIATION */
		if(!in_array($e['expressionValue'], array(
			             'PreMul', 'PreDiv', 'PostMul', 'PostDiv', 'PostPercent',
			             'ModAdd', 'ModSub', 'PreAssignment', 'PostAssignment',
			             '9', /* XXX: what is this? Only used in skillEffect, expressions 1070 and 1071 */
			             ), true)) {
			fatal('expression '.$e['expressionID'].' with operand DEFASSOCIATION has unknown value "'
			      .$e['expressionValue'].'".');
		}

		$dataname = 'value';
		$data = escape_c_string($e['expressionValue']);
	} else if($e['operandID'] === 22) { /* DEFATTRIBUTE */
		if($e['expressionAttributeID'] === null) {
			fatal('expression '.$e['expressionID'].' with operand DEFATTRIBUTE has no attributeID (value: "'
			      .$e['expressionValue'].'").');
		}

		$dataname = 'attributeid';
		$data = $e['expressionAttributeID'].'U';		
	} else if($e['operandID'] === 23) { /* DEFBOOL */
		if(!in_array($e['expressionValue'], array("0", "1"), true)) {
			fatal('expression '.$e['expressionID'].' with operand DEFBOOL has invalid value "'
			      .$e['expressionValue'].'".');
		}

		$dataname = 'value';
		$data = escape_c_string($e['expressionValue']);
	} else if($e['operandID'] === 24) { /* DEFENVIDX */
		if(!in_array($e['expressionValue'], array('Self', 'Char', 'Ship', 'Target', 'Area', 'Other'), true)) {
			fatal('expression '.$e['expressionID'].' with operand DEFENVIDX has unknown value "'
			      .$e['expressionValue'].'".');
		}

		$dataname = 'value';
		$data = escape_c_string($e['expressionValue']);
	} else if($e['operandID'] === 25) { /* DEFFLOAT */
		fatal('expression '.$e['expressionID'].' has unsupported operand DEFFLOAT.');
	} else if($e['operandID'] === 26) { /* DEFGROUP */
		if($e['expressionGroupID'] === null) {
			/* Assume the value is a groupName */
			$mangledname = preg_replace('%(.)([A-Z])%', '$1 $2', $e['expressionValue']);
			foreach($groupsbyid as $g) {
				if($g['groupName'] === $mangledname) {
					$e['expressionGroupID'] = $g['groupID'];
					warn('expression '.$e['expressionID'].' with operand DEFGROUP has no groupID, using '
					     .$g['groupID'].' assuming "'.$e['expressionValue'].'" is a group name');
					break;
				}
			}
		}

		if($e['expressionGroupID'] === null && in_array($e['expressionValue'], array('    None'), true)) {
			warn('expression '.$e['expressionID'].' with operand DEFGROUP has no groupID'
			     .' and has hardcoded value: "'.$e['expressionValue'].'", using groupID 0');

			$e['expressionGroupID'] = 0;
		}

		if($e['expressionGroupID'] === null) {
			fatal('expression '.$e['expressionID'].' with operand DEFGROUP has no groupID (value: "'
			      .$e['expressionValue'].'").');
		}

		$dataname = 'groupid';
		$data = $e['expressionGroupID'].'U';	
	} else if($e['operandID'] === 27) { /* DEFINT */
		if((int)$e['expressionValue'] != $e['expressionValue']) {
			fatal('expression '.$e['expressionID'].' with operand DEFINT has invalid value "'
			      .$e['expressionValue'].'".');
		}

		$dataname = 'value';
		$data = escape_c_string($e['expressionValue']);
	} else if($e['operandID'] === 28) { /* DEFSTRING */
		if($e['expressionValue'] === null) {
			fatal('expression '.$e['expressionID'].' with operand DEFSTRING has no value.');
		}

		$dataname = 'value';
		$data = escape_c_string($e['expressionValue']);
	} else if($e['operandID'] === 29) { /* DEFTYPEID */
		if($e['expressionTypeID'] === null) {
			foreach($usedtypesbyid as $t) {
				if($t['typeName'] === $e['expressionValue']) {
					$e['expressionTypeID'] = $t['typeID'];
					warn('expression '.$e['expressionID'].' with operand DEFTYPEID has no typeID, using '
					     .$t['typeID'].' assuming "'.$e['expressionValue'].'" is a type name');
					break;

				}
			}
		}

		if($e['expressionTypeID'] === null) {
			fatal('expression '.$e['expressionID'].' with operand DEFTYPEID has no typeID (value: "'.
			      $e['expressionValue'].'").');
		}

		$dataname = 'typeid';
		$data = $e['expressionTypeID'].'U';
	} else {
		if($e['expressionValue'] !== null)
			warn('expression '.$e['expressionID'].' has dangling value "'.$e['expressionValue'].'"');

		if($e['expressionAttributeID'] !== null)
			warn('expression '.$e['expressionID'].' has dangling attributeID '.$e['expressionAttributeID']);

		if($e['expressionGroupID'] !== null)
			warn('expression '.$e['expressionID'].' has dangling groupID '.$e['expressionGroupID']);

		if($e['expressionTypeID'] !== null)
			warn('expression '.$e['expressionID'].' has dangling typeID '.$e['expressionTypeID']);

		$dataname = 'value';
		$data = 'NULL';
	}

	fwrite($c, "\t{ "
	       .".id = ".$e['expressionID'].'U'
	       .", .operandid = ".$e['operandID'].'U'
	       .", .arg1 = ".(int)$e['arg1'].'U'
	       .", .arg2 = ".(int)$e['arg2'].'U'
	       .", .".$dataname." = ".$data
	       ." },\n");
}
fwrite($c, "\t{ .id = 0U, .operandid = 0, .arg1 = 0U, .arg2 = 0U, .value = NULL }\n");
fwrite($c, "};\n");
