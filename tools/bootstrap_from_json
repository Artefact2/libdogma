#!/usr/bin/env php
<?php
/* libdogma
 * Copyright (C) 2012, 2013 Romain "Artefact2" Dalmaso <artefact2@gmail.com>
 *
 * This program is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see
 * <http://www.gnu.org/licenses/>.
 */

ini_set('memory_limit', '-1');

function fatal($message) {
	global $argv;

	fwrite(STDERR, $argv[0].": FATAL ".$message."\n");
	die(1);
}

function warn($message) {
	global $argv;

	fwrite(STDERR, $argv[0].": WARNING ".$message."\n");
}

function escape_c_string($str) {
	return '"'.str_replace('"', '\"', $str).'"';
}

$neededjson = array(
	'groups' => 'invgroups.json',
	'types' => 'invtypes.json',
	'attribs' => 'dgmattribs.json',
	'typeattribs' => 'dgmtypeattribs.json',
	'effects' => 'dgmeffects.json',
	'typeeffects' => 'dgmtypeeffects.json',
	'expressions' => 'dgmexpressions.json',
	'operands' => 'dogma_GetOperandsForChar.json',
);
$json = array();

if($argc !== 2) {
	echo "Usage: ".$argv[0]." <path_to_json_dump>\n";
	die(2);
}

$jsonpath = rtrim($argv[1], '/');
foreach($neededjson as $idx => $file) {
	$file = $jsonpath.'/'.$file;
	if(!file_exists($file)) fatal('could not find '.$file);

	$jsontext = file_get_contents($file);
	if($jsontext === false) fatal('could not read '.$file);

	$json[$idx] = json_decode($jsontext, true);
	if(json_last_error() !== JSON_ERROR_NONE) fatal('could not parse JSON in '.$file);
}

$targetsource = __DIR__.'/../src/tables-data.c';
if(file_exists($targetsource)) fatal('cowardly refusing to overwrite '.$targetsource);

$c = fopen($targetsource, 'xb');
if($c === false) fatal('could not open '.$targetsource.' for writing');

$targetheader = __DIR__.'/../src/operands.h';
if(file_exists($targetheader)) fatal('cowardly refusing to overwrite '.$targetheader);

$h = fopen($targetheader, 'xb');
if($h === false) fatal('could not open '.$targetheader.' for writing');


fwrite(
	$c,
	"/* libdogma */\n\n"
	."/* THIS FILE HAS BEEN AUTOGENERATED. DO NOT MODIFY IT MANUALLY.\n"
	." *\n"
	." * ".__FILE__."\n"
	." * ".date('r')." */\n"
	."\n\n");

fwrite(
	$h,
	"/* libdogma */\n\n"
	."/* THIS FILE HAS BEEN AUTOGENERATED. DO NOT MODIFY IT MANUALLY.\n"
	." *\n"
	." * ".__FILE__."\n"
	." * ".date('r')." */\n"
	."\n"
	."#ifndef _DOGMA_OPERANDS_H\n"
	."#define _DOGMA_OPERANDS_H 1 \n"
	."\n\n");

/* -------- Types -------- */

$groupsbyid = array();
$usedtypesbyid = array();

foreach($json['groups'] as $g) {
	$groupsbyid[$g['groupID']] = $g;
}
ksort($groupsbyid);

foreach($json['types'] as $t) {
	if($t['published'] !== true || $groupsbyid[$t['groupID']]['published'] !== true
	   || !in_array($groupsbyid[$t['groupID']]['categoryID'], array(6, 7, 8, 16, 18, 20, 32), true)) {
		continue;
	}

	$usedtypesbyid[$t['typeID']] = $t;
}
ksort($usedtypesbyid);

fwrite($c, "static const dogma_type_t dogma_table_types[] = {\n");
foreach($usedtypesbyid as $t) {
	fwrite($c, "\t{ "
	       .$t['typeID'].'U'
	       .", ".$t['volume']
	       .", ".$t['mass']
	       .", ".$t['capacity']
	       .", ".$t['groupID'].'U'
	       .", ".$groupsbyid[$t['groupID']]['categoryID'].'U'
	       ." },\n");
}
fwrite($c, "\t{ 0U, 0, 0, 0, 0U, 0U }\n");
fwrite($c, "};\n");

/* -------- Attributes -------- */

$usedattributesbyid = array();
$usedtypeattributes = array();

foreach($json['typeattribs'] as $ta) {
	if(!isset($usedtypesbyid[$ta['typeID']])) {
		continue;
	}

	$usedattributesbyid[$ta['attributeID']] = true;
	$usedtypeattributes[] = $ta;
}

foreach($json['attribs'] as $a) {
	if(!isset($usedattributesbyid[$a['attributeID']])) {
		continue;
	}

	$usedattributesbyid[$a['attributeID']] = $a;
}
ksort($usedattributesbyid);

fwrite($c, "static const dogma_attribute_t dogma_table_attributes[] = {\n");
foreach($usedattributesbyid as $a) {
	fwrite($c, "\t{ "
	       .$a['attributeID'].'U'
	       .", ".$a['defaultValue']
	       .", ".($a['stackable'] ? 'true' : 'false')
	       .", ".($a['highIsGood'] ? 'true' : 'false')
	       ." },\n");
}
fwrite($c, "\t{ 0U, 0, false, false }\n");
fwrite($c, "};\n");

/* -------- Effects -------- */

$usedeffectsbyid = array();
$usedtypeeffects = array();

foreach($json['typeeffects'] as $te) {
	if(!isset($usedtypesbyid[$te['typeID']])) {
		continue;
	}

	$usedeffectsbyid[$te['effectID']] = true;
	$usedtypeeffects[] = $te;
}

/* Add the custom effect to the Nanite Repair Paste */
$usedtypeeffects[] = array(
	'effectID' => -10,
	'typeID' => 28668
);

foreach($json['effects'] as $e) {
	if(!isset($usedeffectsbyid[$e['effectID']])) {
		continue;
	}

	$usedeffectsbyid[$e['effectID']] = $e;
}

/* Effect for the Nanite Repair Paste when used in an Ancillary Armor Repairer */
$usedeffectsbyid[-10] = array(
	'effectID' => -10,
	'effectCategory' => 0,
	'preExpression' => -10,
	'postExpression' => -9,
	'durationAttributeID' => null,
	'trackingSpeedAttributeID' => null,
	'dischargeAttributeID' => null,
	'rangeAttributeID' => null,
	'falloffAttributeID' => null
);

ksort($usedeffectsbyid);


/* skillEffect: bogus/unknown DEFASSOCIATION, skills are handled
 * correctly without it anyway */
$usedeffectsbyid[132]['preExpression'] = -1;
$usedeffectsbyid[132]['postExpression'] = -1;

/* online: inconsistent category, WTF? */
$usedeffectsbyid[16]['categoryID'] = 4;

/* online: skip all the CPU/Power/Skill checks, they only make sense
 * in game */
$usedeffectsbyid[16]['preExpression'] = 178;
$usedeffectsbyid[16]['postExpression'] = 180;

/* turretFitted: skip the hardpoint check */
$usedeffectsbyid[42]['preExpression'] = 304;
$usedeffectsbyid[42]['postExpression'] = 305;

/* launcherFitted: skip the hardpoint check */
$usedeffectsbyid[40]['preExpression'] = 318;
$usedeffectsbyid[40]['postExpression'] = 319;

/* TODO: penalties (AB/MWD, agility/sigradius) of warpDisruptSphere */

/* maxRangeHiddenPreAssignmentWarpScrambleRange: not sure what this is or what it does, get rid of it */
$usedeffectsbyid[4894]['preExpression'] = -1;
$usedeffectsbyid[4894]['postExpression'] = -1;
/* scriptWarpDisruptionFieldGeneratorSetScriptCapacitorNeedHidden: same */
$usedeffectsbyid[3615]['preExpression'] = -1;
$usedeffectsbyid[3615]['postExpression'] = -1;



fwrite($c, "static const dogma_effect_t dogma_table_effects[] = {\n");
foreach($usedeffectsbyid as $e) {
	fwrite($c, "\t{ "
	       .$e['effectID']
	       .", ".$e['effectCategory'].'U'
	       .", ".$e['preExpression'].'U'
	       .", ".$e['postExpression'].'U'
	       .", ".(int)$e['durationAttributeID'].'U'
	       .", ".(int)$e['trackingSpeedAttributeID'].'U'
	       .", ".(int)$e['dischargeAttributeID'].'U'
	       .", ".(int)$e['rangeAttributeID'].'U'
	       .", ".(int)$e['falloffAttributeID'].'U'
	       ." },\n");
}
fwrite($c, "\t{ 0, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U }\n");
fwrite($c, "};\n");

/* -------- Type attributes / Type effects -------- */

usort($usedtypeattributes, function($a, $b) {
		$delta1 = $a['typeID'] - $b['typeID'];
		$delta2 = $a['attributeID'] - $b['attributeID'];

		return ($delta1 !== 0) ? $delta1 : $delta2;
	});
usort($usedtypeeffects, function($a, $b) {
		$delta1 = $a['typeID'] - $b['typeID'];
		$delta2 = $a['effectID'] - $b['effectID'];

		return ($delta1 !== 0) ? $delta1 : $delta2;
	});

fwrite($c, "static const dogma_type_attribute_t dogma_table_type_attributes[] = {\n");
foreach($usedtypeattributes as $ta) {
	fwrite($c, "\t{ "
	       .$ta['typeID'].'U'
	       .", ".$ta['attributeID'].'U'
	       .", ".$ta['value']
	       ." },\n");
}
fwrite($c, "\t{ 0U, 0U, 0 }\n");
fwrite($c, "};\n");

fwrite($c, "static const dogma_type_effect_t dogma_table_type_effects[] = {\n");
foreach($usedtypeeffects as $te) {
	fwrite($c, "\t{ "
	       .$te['typeID'].'U'
	       .", ".$te['effectID']
	       ." },\n");
}
fwrite($c, "\t{ 0U, 0 }\n");
fwrite($c, "};\n");

/* -------- Operands -------- */

/* Assume all operands are used, there are not that many and the only
 * overhead would be at compile-time anyway */
$operandsbyid = array();

foreach($json['operands'] as $op) {
	$operandsbyid[$op['operandID']] = $op;
}
ksort($operandsbyid);

fwrite($h, "enum dogma_operand_e {\n");
foreach($operandsbyid as $op) {
	fwrite($h, "\t/* ".$op['description']."\n"
	       ."\t * ".$op['format']." */\n"
	       ."\tDOGMA_".$op['operandKey']."=".$op['operandID'].",\n\n");
}
fwrite(
	$h,
	"};\n"
	."typedef enum dogma_operand_e dogma_operand_t;\n");

fwrite($h, "\n#endif\n");

/* -------- Expressions -------- */

$expressionsbyid = array();
$usedexpressionsbyid = array();
$expressionstoadd = array();

foreach($json['expressions'] as $e) {
	$expressionsbyid[$e['expressionID']] = $e;
}

/* Generic dummy expression */
$expressionsbyid[-1] = array(
	'expressionID' => -1,
	'operandID' => 23, /* DEFBOOL */
	'expressionValue' => '0',
	'expressionAttributeID' => null,
	'expressionGroupID' => null,
	'expressionTypeID' => null,
	'arg1' => null,
	'arg2' => null,
	);

/* Ancillary Armor Repairer charge expression:
 * ((CurrentOther->armorDamageAmount).(PostMul)).AddItemModifier (CurrentOther->chargedArmorDamageMultiplier)
 */
$expressionsbyid[-10] = array(
	'expressionID' => -10,
	'operandID' => 6, /* AIM */
	'expressionValue' => null,
	'expressionAttributeID' => null,
	'expressionGroupID' => null,
	'expressionTypeID' => null,
	'arg1' => -7, /* (CurrentOther->armorDamageAmount).(PostMul) */
	'arg2' => -6, /* CurrentOther->chargedArmorDamageMultiplier */ 
	);
$expressionsbyid[-9] = array(
	'expressionID' => -9,
	'operandID' => 58, /* RIM */
	'expressionValue' => null,
	'expressionAttributeID' => null,
	'expressionGroupID' => null,
	'expressionTypeID' => null,
	'arg1' => -7, /* (CurrentOther->armorDamageAmount).(PostMul) */
	'arg2' => -6, /* CurrentOther->chargedArmorDamageMultiplier */ 
	);
$expressionsbyid[-8] = array(
	'expressionID' => -8,
	'operandID' => 12, /* ATT */
	'expressionValue' => null,
	'expressionAttributeID' => null,
	'expressionGroupID' => null,
	'expressionTypeID' => null,
	'arg1' => 3043, /* CurrentOther */
	'arg2' => 234, /* armorDamageAmount */
	);
$expressionsbyid[-7] = array(
	'expressionID' => -7,
	'operandID' => 31, /* EFF */
	'expressionValue' => null,
	'expressionAttributeID' => null,
	'expressionGroupID' => null,
	'expressionTypeID' => null,
	'arg1' => 5, /* PreMul */
	'arg2' => -8, /* CurrentOther->armorDamageAmount */
	);
$expressionsbyid[-6] = array(
	'expressionID' => -6,
	'operandID' => 12, /* ATT */
	'expressionValue' => null,
	'expressionAttributeID' => null,
	'expressionGroupID' => null,
	'expressionTypeID' => null,
	'arg1' => 3043, /* CurrentOther */
	'arg2' => -5, /* chargedArmorDamageMultiplier */
	);
$expressionsbyid[-5] = array(
	'expressionID' => -5,
	'operandID' => 22, /* DEFATTRIBUTE */
	'expressionValue' => null,
	'expressionAttributeID' => 1886,
	'expressionGroupID' => null,
	'expressionTypeID' => null,
	'arg1' => null,
	'arg2' => null,
	);

foreach($usedeffectsbyid as $e) {
	$expressionstoadd[] = $e['preExpression'];
	$expressionstoadd[] = $e['postExpression'];
}

while($expressionstoadd !== array()) {
	$addfurther = array();

	foreach($expressionstoadd as $id) {
		if($id === null) continue;
		if(isset($usedexpressionsbyid[$id])) continue;

		$usedexpressionsbyid[$id] = $expressionsbyid[$id];
		$addfurther[] = $expressionsbyid[$id]['arg1'];
		$addfurther[] = $expressionsbyid[$id]['arg2'];
	}

	$expressionstoadd = $addfurther;
}

ksort($usedexpressionsbyid);
unset($expressionsbyid);

fwrite($c, "static const dogma_expression_t dogma_table_expressions[] = {\n");
foreach($usedexpressionsbyid as $e) {
	if($e['operandID'] === 21) { /* DEFASSOCIATION */
		/* Incorrect values will produce compilation errors, so no
		 * checks here */
		$dataname = 'assoctype';
		$data = "DOGMA_".$e['expressionValue'];
	} else if($e['operandID'] === 22) { /* DEFATTRIBUTE */
		if($e['expressionAttributeID'] === null) {
			fatal('expression '.$e['expressionID'].' with operand DEFATTRIBUTE has no attributeID (value: "'
			      .$e['expressionValue'].'").');
		}

		$dataname = 'attributeid';
		$data = $e['expressionAttributeID'].'U';		
	} else if($e['operandID'] === 23) { /* DEFBOOL */
		if(!in_array($e['expressionValue'], array("0", "1"), true)) {
			fatal('expression '.$e['expressionID'].' with operand DEFBOOL has invalid value "'
			      .$e['expressionValue'].'".');
		}

		$dataname = 'boolv';
		$data = ($e['expressionValue'] === '1') ? 'true' : 'false';
	} else if($e['operandID'] === 24) { /* DEFENVIDX */
		/* Incorrect values will produce compilation errors, so no
		 * checks here */
		$dataname = 'envidx';
		$data = 'DOGMA_'.$e['expressionValue'];
	} else if($e['operandID'] === 25) { /* DEFFLOAT */
		$dataname = 'floatv';
		$data = $e['expressionValue'];
	} else if($e['operandID'] === 26) { /* DEFGROUP */
		if($e['expressionGroupID'] === null) {
			/* Assume the value is a groupName */
			$mangledname = preg_replace('%(.)([A-Z])%', '$1 $2', $e['expressionValue']);
			foreach($groupsbyid as $g) {
				if($g['groupName'] === $mangledname) {
					$e['expressionGroupID'] = $g['groupID'];
					warn('expression '.$e['expressionID'].' with operand DEFGROUP has no groupID, using '
					     .$g['groupID'].' assuming "'.$e['expressionValue'].'" is a group name');
					break;
				}
			}
		}

		if($e['expressionGroupID'] === null && in_array($e['expressionValue'], array('    None'), true)) {
			warn('expression '.$e['expressionID'].' with operand DEFGROUP has no groupID'
			     .' and has hardcoded value: "'.$e['expressionValue'].'", using groupID 0');

			$e['expressionGroupID'] = 0;
		}

		if($e['expressionGroupID'] === null) {
			fatal('expression '.$e['expressionID'].' with operand DEFGROUP has no groupID (value: "'
			      .$e['expressionValue'].'").');
		}

		$dataname = 'groupid';
		$data = $e['expressionGroupID'].'U';	
	} else if($e['operandID'] === 27) { /* DEFINT */
		if((int)$e['expressionValue'] != $e['expressionValue']) {
			fatal('expression '.$e['expressionID'].' with operand DEFINT has invalid value "'
			      .$e['expressionValue'].'".');
		}

		$dataname = 'intv';
		$data = $e['expressionValue'];
	} else if($e['operandID'] === 28) { /* DEFSTRING */
		if($e['expressionValue'] === null) {
			fatal('expression '.$e['expressionID'].' with operand DEFSTRING has no value.');
		}

		$dataname = 'value';
		$data = escape_c_string($e['expressionValue']);
	} else if($e['operandID'] === 29) { /* DEFTYPEID */
		if($e['expressionTypeID'] === null) {
			foreach($usedtypesbyid as $t) {
				if($t['typeName'] === $e['expressionValue']) {
					$e['expressionTypeID'] = $t['typeID'];
					warn('expression '.$e['expressionID'].' with operand DEFTYPEID has no typeID, using '
					     .$t['typeID'].' assuming "'.$e['expressionValue'].'" is a type name');
					break;

				}
			}
		}

		if($e['expressionTypeID'] === null) {
			fatal('expression '.$e['expressionID'].' with operand DEFTYPEID has no typeID (value: "'.
			      $e['expressionValue'].'").');
		}

		$dataname = 'typeid';
		$data = $e['expressionTypeID'].'U';
	} else {
		if($e['expressionValue'] !== null)
			warn('expression '.$e['expressionID'].' has dangling value "'.$e['expressionValue'].'"');

		if($e['expressionAttributeID'] !== null)
			warn('expression '.$e['expressionID'].' has dangling attributeID '.$e['expressionAttributeID']);

		if($e['expressionGroupID'] !== null)
			warn('expression '.$e['expressionID'].' has dangling groupID '.$e['expressionGroupID']);

		if($e['expressionTypeID'] !== null)
			warn('expression '.$e['expressionID'].' has dangling typeID '.$e['expressionTypeID']);

		$dataname = 'value';
		$data = 'NULL';
	}

	fwrite($c, "\t{ "
	       .".id = ".$e['expressionID'].'U'
	       .", .operand = DOGMA_".$operandsbyid[$e['operandID']]['operandKey']
	       .", .arg1 = ".(int)$e['arg1']
	       .", .arg2 = ".(int)$e['arg2']
	       .", .".$dataname." = ".$data
	       ." },\n");
}
fwrite($c, "\t{ .id = 0U, .operand = 0, .arg1 = 0, .arg2 = 0, .value = NULL }\n");
fwrite($c, "};\n");
